---
title:  "Python 문법 정리"
excerpt: "코딩테스트를 위한 Python 문법"
categories:
  - Python
tags:
  - [Python]
toc: true
toc_sticky: true
 
date: 2021-07-03
last_modified_at: 2021-07-03
---
# 1. 자료형
## 수 자료형   
데이터는 모두 수로 표현할 수 있다.
### 정수형   
- 정수를 다루는 자료형   
- 양의 정수, 음의 정수, 0이 있다.   
### 실수형
- 소수점 아래의 데이터를 포함하는 수 자료형으로 파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리한다.
- 소수부가 0이거나, 정수부가 0인 소수는 0을 생략하고 작성할 수 있다.
- 실수형 데이터를 표현하는 방식으로 파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다. e 다음에 오는 수는 10의 지수부를 의미한다. ex) le9 는 10의 9제곱이 된다.
- 최단 경로 문제에서는 도달할 수 없는 노드에 대하여 거리를 '무한(INF)'으로 설정하곤 한다. 최댓값이 10억 미만이라면 무한(INF)을 표현할 때 10억을 사용할 수 있다. -> 이때 일일이 10억을 특정 변수에 대입하는 일은 번거로워 지수 표현 방식인 le9로 표현할 수 있는 것이다.
- 또한 큰 수를 표현할 때, 0의 개수가 많아지게 되면 자릿수가 헷갈리는 경우가 많기 때문에 10억을 코드에 입력하는 것 보다는 le9로 표현하는 것이 실수할 확률이 적다.
- 10진수 체계에서는 0.3과 0.6을 더한 값이 0.9로 정확히 떨어지지만, 2진수에서는 0.9를 정확히 표현할 수 있는 방법이 없다. -> 따라서 소수점 값을 비교하는 작업이 필요한 문제라면 round()함수를 이용할 수 있다.
- round() 함수를 호출할 때 첫 번째 인자는 실수형 데이터이고, 두 번째 인자는 (반올림하고자 하는 위치 -1) 이다.
### 수 자료형의 연산
```
a=7
b=3
#나누기
print(a/b)
#나머지
print(a%b)
#몫
print(a//b)   
```
## 리스트 자료형
- 리스트는 여러개의 데이터를 연속적으로 담아 처리하기 위해 사용할 수 있다.
- 내부적으로 연결 리스트 자료구조를 채택하고 있어서 append(), remove() 등의 메서드를 지원한다.

1. 리스트 만들기
- 리스트는 대괄호([])안에 원소를 넣어 초기화하며, 쉼표(,)로 원소를 구분한다.
- 비어있는 리스트를 선언하고자 할 때는 list() 혹은 간단히 대괄호([])를 이용할 수 있다.
- 비어있는 리스트를 선언하고자 할 때는 list() 혹은 간단히 대괄호([])를 이용할 수 있다.   

  ```
  #빈 리스트 선언 방법
  a= list()
  a=[]
  #크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
  n=10
  a=[0]*n
  ```

2. 리스트의 인덱싱과 슬라이싱
- 인덱스값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 한다.
- 인덱스값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 한다.   

  ``` 
  #뒤에서 세 번째 원소 출력
  print(a[-3])
  #두 번째 원소부터 네 번째 원소까지 슬라이싱
  print(a[1:4])
  ```

3. 리스트 컴프리헨션
- 리스트를 초기화하는 방법 중 하나이다.
리스트 컴프리헨션을 이용하면 대괄호([]) 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있다.
리스트 컴프리헨션을 이용하면 대괄호([]) 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있다.   


  ``` 
  #0부터 19까지의 수 중에서 홀수만 포함하는 리스트
  array = [i for i in range(20) if i%2==1]
    
  array = [i for i in range(20) if i%2==1]    
  #1부터 9까지의 수의 제곱 값을 포함하는 리스트
  array = [i*i for i in range(1,10)]
  ```

 - 이러한 리스트 컴프리헨션은 코딩테스트에서 2차원 리스트를 초기화 할 때 매우 효과적으로 사용될 수 있다.
 - 이러한 리스트 컴프리헨션은 코딩테스트에서 2차원 리스트를 초기화 할 때 매우 효과적으로 사용될 수 있다.   

    ``` 
    #N X M 크기의 2차원 리스트 초기화
    n=3
    m=4
    array=[[0]*m for _ in range(5)]
    ```
    

4. 리스트 관련 기타 메서드
- append()  -리스트에 원소를 하나 삽입할 때 사용한다  O(1)
- sort() - 기본 정렬 기능으로 오름차순으로 정렬 O(NlogN)
- sort(reverse=TRUE) - 내림차순으로 정렬 O(NlogN)
- reverse() - 리스트의 원소의 순서를 모두 뒤집어 놓는다 O(N)
- insert() - 특정한 인덱스 위치에 원소를 삽입할 때 사용한다 O(N)
- count() - 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다 O(N)
- remove() - 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다 O(N)
## 문자열 자료형
1. 문자열 초기화
- 문자열 변수를 초기화할 때는 큰따옴표(")나 작은따옴표(')를 이용한다.
2. 문자열 연산
- 문자열 변수에 덧셈(+)을 이용하면 단순히 문자열이 더해져서 연결된다.
- 문자열 변수를 양의 정수와 곱하는 겨우, 문자열이 그 값만큼 여러 번 더해진다.
- 파이썬 문자열은 내부적으로 리스트와 같이 처리된다. 문자열은 여러 개의 문자가 합쳐진 리스트라고 볼 수 있다.
## 튜플 자료형
- 파이썬의 튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있다.
- 튜플은 한 번 선언된 값을 변경할 수 없다.
- 리스트는 대괄호([])를 이용하지만, 튜플은 소괄호 (())를 이용한다.
## 사전 자료형
- 사전 자료형은 키와 값의 쌍을 데이터로 가지는 자료형이다.
- 앞서 다루었던 리스트나 튜플은 값을 순차적으로 저장한다는 특징이 있다. 하지만 사전 자료형은 키-값 쌍을 데이터로 가진다는 점에서, 우리가 원하는 변경 불가능한 데이터를 키로 사용할 수 있다. 
  ```
  data=dict()
  data['사과']='Apple'
  data['바나나']='Banana'
  data['코코넛']='Coconut'
  print(data)  => {'사과':'Apple', '바나나':'Banana','코코넛':'Coconut'}
  ```
        
 ### 사전 자료형 관련 함수
 - 키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용하며, 값 데이터만을 뽑아서 리스트로 이용할 때는 values() 함수를 이용한다. 
    ```
    #키 데이터만 담은 리스트
    key_list = data.keys()
    #값 데이터만 담은 리스트
    value_list = data.values()
    결과
    dict_keys(['사과','바나나','코코넛'])
    dict_values(['Apple','Banana','Coconut'])
    ```
## 집합 자료형
- 중복을 허용하지 않는다.
- 순서가 없다.
- '특정한 데이터가 이미 등장한 적이 있는지 여부'를 체크할 때 매우 효과적이다.
  ```
  #집합 자료형 초기화 방법1
  data = set([1,1,2,3,4,4,5])
  #집합 자료형 초기화 방법2
  data={1,1,2,3,4,4,5}
  집합 자료형의 연산
  a = set([1,2,3,4,5])
  b = set([3,4,5,6,7])
  #합집합
  a|b  => {1,2,3,4,5,6,7}
  #교집합
  a&b => {3,4,5}
  #차집합
  a-b => {1,2}
  #새로운 원소 추가
  data.add(4)
  #새로운 원소 여러 개 추가
  data.update([5,6])
  #특정한 값을 갖는 원소 삭제
  data.remove(3)
  ```
# 2. 조건문
- 파이썬에서 조건문을 작성할 때는 if ~ elif ~ else문을 이용한다. 조건문을 사용할 때 elif 혹은 else 부분은 경우에 따라서 사용하지 않아도 된다.
  ```
  if 조건문 1:
    조건문 1이 True일 때 실행되는 코드
  elif 조건문 2:
    조건문 1에 해당하지 않고, 조건문 2가 True일 때 실행되는 코드
  else:
    위의 모든 조건문이 모두 True 값이 아닐 때 실행되는 코드
  #조건부 표현식
  score=85
  result = "Success" if score >=80 else "Fail"
  #리스트에 있는 원소의 값을 변경해서 또 다른 리스트 생성
  a=[1,2,3,4,5,5,5]
  remove_set={3,5}
  result = [i for i in a if i not in remove_set]
  print(result) => [1,2,4]
  ```
# 3. 반복문
## while문
- while문은 조건문이 참일 때에 한해서, 반복적으로 코드가 수행된다.
  ```
  #i가 9보다 작거나 같을 때 아래 코드를 반복적으로 실행
  while i <= 9:
    if i % 2 ==1:
      result += i
    i += 1
  ```
## for문
- in 뒤에 오는 데이터에 포함되어 있는 모든 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문한다.  in 뒤에 오는 데이터로는 리스트, 튜플, 문자열 등이 사용될 수 있다.
  ```
  for 변수 in 리스트:
      실행할 소스코드
  #i는 1부터 9까지의 모든 값을 순회
  for i in range(1, 10):
      result +=i; 
  #range()의 값으로 하나의 값만을 넣으면, 자동으로 시작 값은 0이 된다
  for i in range(5):
    result +=i;
  ```
# 4. 함수
- 동일한 알고리즘을 반복적으로 수행해야 할 때 함수는 중요하게 사용된다.
  ```
  def 함수명(매개변수):
    실행할 소스코드
    return 반환 값
  def add(a,b):
      print('함수의 결과:', a+b)
  add(b=3,a=7)   ->   함수의 결과: 10
  #람다 표현식으로 구현한 add() 메서드
  print((lambda a,b: a+b)(3,7))
  ```
# 5. 입출력
- 일반적으로 입력 과정에서는 먼저 데이터의 개수가 첫 번째 줄에 주오지고, 처리할 데이터는 그다음 줄에 주어지는 경우가 많다.
  ```
  #데이터의 개수 입력
  n= int(input())
  #각 데이터를 공백으로 구분하여 입력
  data = list(map(int,input().split())
  data.sort(reverse=True)  => [99,90,75,65,34]
  ```
- 파이썬의 기본 input() 함수는 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있기 때문에 sys라이브러리에 정의되어 있는 sys.stdin.readline() 함수를 이용한다.
  ```
  import sys
  
  data= sys.stdin.readline().rstrip()
  ```
# 6. 주요 라이브러리의 문법과 유의점
표준 라이브러리란 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리를 의미한다.
- 내장 함수: print(), input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리이다.
- itertools: 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리이다. 순열과 조합 라이브러리를 제공한다.
- heapq: 힙(Heap) 기능을 제공하는 라이브러리이다. 우선순위 큐 기능을 구현하기 위해 사용된다.
- visect: 이진 탐색 기능을 제공하는 라이브러리이다.
- collections: 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리이다.
- math: 필수적인 수학적 기능을 제공하는 라이브러리이다. 팩토리얼, 제곱근, 최대공약수, 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함하고 있다.
### 1. 내장 함수
- 별도의 import 명령어 없이 바로 사용할 수 있는 내장 함수 (input, print)
- sum()
  ```
  result = sum([1,2,3,4,5])   => 15
  ```
- min()
  ```
  result = min(7,3,5,2)       => 2
  ```
- max()
  ```
  result = max(7,3,5,2)       => 7
  ```
- eval()
  ```
  result = eval("(3+5)*7")    => 56
  ```
- sorted()
  ```
  result = sorted([9,1,8,5,4]) #오름차순 정렬
  result = sorted([9,1,8,4,5], reverse = True) #내림차순 정렬
  #파이썬에서는 리스트의 원소로 리스트나 튜플이 존재할 때 특정한 기준에 따라서 정렬을 수행할 수 있다.
  result = sorted([('홍길동',35),('이순신',75)], key=lambda x: x[1], reverse= True)
  ```
### 2. itertools
- itertools는 파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리이다.
- 가장 유용하게 사용할 수 있는 클래스는 permutations, combinations이다.
- permutations (순열)
  ```
  from itertools import permutations
  
  data= ['A','B','C']
  result = list(permutations(data,3)) #모든 순열 구하기
  ```
- combinations(조합)
  ```
  from itertools import combinations
  data=['A','B','C']
  result = list(combinations(data,2)) #2개를 뽑는 모든 조합 구하기
  ```
### 3. heapq
- heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐 기능을 구현하고자 할 때 사용된다.
- 힙에 원소를 삽입할 때는 heapq.heappush() 메서드를 이용하고, 힙에서 원소를 꺼내고자 할 때는 heapq.heappop() 메서드를 이용한다.
### 4. bisect
- bisect 라이브러리는 '정렬된 배열'에서 특정한 원소를 찾아야 할 때 매우 효과적으로 사용된다. 
- bisect_left() 함수와 bisect_right() 함수가 가장 중요하게 사용되며, 이 두 함수는 시간 복잡도 O(logN)에 동작한다.
- bisect_left(a,x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
- bisect_right(a,x) : 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드
### 5. collections
- 보통 파이썬에서는 deque를 사용해 큐를 구현한다. 
- deque는 연속적으로 나열된 데이터의 시작 부분이나 끝부분에 데이터를 삽입하거나 삭제할 때 매우 효과적으로 사용될 수 있다.
- deque는 스택이나 큐의 기능을 모두 포함한다고도 볼 수 있기 때문에 스택 혹은 큐 자료구조의 대용으로 사용될 수 있다.
- 첫 번째 원소를 제거할 때 popleft()를 사용하며, 마지막 원소를 제거할 때 pop()을 사용한다.
- 첫 번째 인덱스에 원소 x를 삽입할 때 appendleft(x)를 사용하며, 마짐가 인덱스에 원소를 삽입할 때 append(x)를 사용한다.
- Counter는 등장 횟수를 세는 기능을 제공한다.
  ```
  from collections import Counter
  counter = Counter(['red','blue','red','green','blue','blue'])
  print(count['blue'])  #'blue'가 등장한 횟수 출력 => 3
  print(dict(counter))  #사전 자료형으로 변환 => {'red':2, 'blue':3, 'green':1}
  ```
### 6. math
- 수학 계산을 요구하는 문제를 만났을 때 효과적으로 사용될 수 있다.
  ```
  import math
  print(math.factorial(5)) #5팩토리얼을 출력 => 120
  print(math.sqrt(7)) #7의 제곱근을 출력 => 2.6457513...
  print(math.gcd(21,14)) #최대공약수 츨력 => 7
  print(math.pi) #파이(pi)출력 => 3.141592653589793
  print(math.e) #자연상수 e 출력 => 2.718281828459045
  ```