---
title:  "Java 개념 정리V"
excerpt: "람다와 스트림"

categories:
  - Java
tags:
  - [Java]

toc: true
toc_sticky: true
 
date: 2022-01-10
last_modified_at: 2022-01-10
---

# Java 개념 정리

## 람다와 스트림 (Lambda & Stream)
## 1. 람다(Lambda)

### 1-1. 람다식(Lambda Expression)이란;
- 함수(메서드)를 간단한 '식(Expression)' 으로 표현한는 방법
    ```java
    int max(int a, int b){
        return a > b  a : b;  
    }
            ↓

    (a,b) -> a > b ? a : b
    ```
- 익명 함수(이름이 없는 함수, annonymous function)
    ```java
    int max(int a, int b){
        return a > b ? a : b;
    }
            ↓

    (int a, int b) -> {
        return a > b ? a : b;
    }
    ```
- 함수와 메서드의 차이
  - 근본적으로 동일. 함수는 일반적 용어, 메서드는 객체지향개념 용어
  - 함수는 클래스에 독립적 ,메서드는 클래스에 종속적

### 1-2. 람다식 작성하기
1. 메서드의 이름과 반환타입을 제거하고 '->'를 볼록{} 앞에 추가한다.
    ```java
    int max(int a, int b){
        return a > b ? a : b;
    }
            ↓

    (int a, int b) -> {
        return a > b ? a : b;
    }
    ```
2. 반환 값이 있는 경우, 식이나 값만 적고 return문 생략 가능 ( 끝에 ' ;' 안 붙암)
    ```java
    (int a, int b)->{
        return a > b ? a : b;
    }
                ↓

    (int a, int b) -> a > b ? a : b
    ```

3. 매개변수의 타입이 추론 가능하면 생략가능(대부분의 경우 생략 가능)
    ```java
    (int a, int b) -> a > b ? a : b

                ↓

    (a,b) -> a > b ? a : b
    ```
#### 주의 사항
- 매개변수가 하나인 경우, 괄호() 생략 가능 (타입이 없을 때만)
    ```java
    a -> a * a //OK
    int a -> a * a //에러 (int a)->a*a
    ```
- 블록 안의 문장이 하나뿐 일 때, 괄호{} 생략 가능(끝에 ';' 안 붙임)
    ```java
    (int i) -> System.out.println(i)
    ```
- 단, 하나뿐인 문장이 return문이면 괄호{} 생략 불가
    ```java
    (int a, int b) -> {return a > b ? a : b ; }
    ```
### 1-3. 함수형 인터페이스
- 람다식은 익명 함수? 사실은 익명 객체
    ```java
    new Object(){
        int max(int a, int b){
            return a > b ? a : b;
        }
    }
    ```
- 람다식(익명 객체)을 다루기 위한 참조변수가 필요. 참조변서의 타입은?
    ```java
    Object obj = new Object(){
        int max(int a, int b){
            return a > b ? a : b;
        }
    };
    int value = obj.max(3,5);  //에러. Object클래스에 max()가 없음
    ```
- 함수형 인터페이스 - 단 하나의 추상 메서드만 선언된 인터페이스
    ```java
    interface MyFunction{
        public abstract int max(int a , int b);
    }

    MyFunction f = new MyFunction(){
        public int max(int a, int b){
            return a > b ? a : b;
        }
    };

    int value = f.max(3,5);  //OK. MyFunction에 max()가 있음
    ```
- 함수형 인터페이스 타입의 참조변수로 람다식을 참조할 수 있음 (단, 함수형 인터페이스의 메서드와 람다식의 매개변수 개수와 반환타입이 일치해야 함.)
    ```java
    MyFunction f = (a,b) -> a > b ? a : b;
    int value = f.max(3,5);  //실제로는 람다식(익명 함수)이 호출됨
    ```
- 익명 객체를 람다식으로 대체
    ```java
    List<String> list = Arrays.asList("abc","aaa","bbb","ddd","aaa");
    Collections.sort(list,(s1,s2)-> s2.compareTo(s1));
    ```
### 1-4. java.util.function패키지
- 자주 사용되는 다양한 함수형 인터페이스를 제공
    ![함수형인터페이스](https://user-images.githubusercontent.com/62706198/148722977-f841f6b4-ef7e-406d-9d8b-e9b2b657006b.PNG)
    ```java
    Predicate<String> isEmptyStr = s-> s.length()==0;
    String s = "";

    if(isEmptyStr.test(s)) //if(s.length()==0)
        System.out.println("This is an empty String.");
    ```
- 매개변수가 2개인 함수형 인터페이스
    ![함수형인터페이스2](https://user-images.githubusercontent.com/62706198/148723496-c1e2367f-70ef-4043-a619-62b59aef08cd.PNG)

    ```java
    @FunctionalInterface
    interface TriFunction<T,U,V,R>{
        R apply(T t, U u, V v);
    }
    ```
- 매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스
    ![함수형인터페이스3](https://user-images.githubusercontent.com/62706198/148723747-34c4d3f4-4c60-4da7-98f9-be843e49f953.PNG)
    ```java
    @FunctinalInterface
    public interface UnaryOperator<T> extends Function<T,T>{
        static <T> UnaryOperator<T> identity(){
            return t -> t;
        }
    }
    ```
- 함수형 인터페이스를 사용하는 컬렉션 프레임웍의 메서드
    ![함수형인터페이스4](https://user-images.githubusercontent.com/62706198/148730187-e6a7f9ba-41a5-4323-9096-1183e097495e.PNG)
    ```java
    list.forEach(i->System.out.print(i+",")); //list의 모든 요소를 출력
    list.removeIf(x->x%2==0||x%3==0); //2또는 3의 배수를 제거
    list.remplace(i->i&10);  //모든 요소에 10을 곱한다.
    //map의 모든 요소를 {k,v}의 형식으로 출력
    amp.forEach((k,v)->System.out.println("{"+k+","+v+"},"));
    ```

- 기본형을 사용하는 함수형 인터페이스
    ![함수형인터페이스5](https://user-images.githubusercontent.com/62706198/148730501-8b76d79a-c65f-4cdf-88b8-05882fc8ebab.PNG)
    ```java
    IntSupplier s = () -> (int)(Math.random()*100)+1;
    static void makeRandomList(IntSupplier s, int[] arr){
        for(int i=0;i<arr.length;i++)
            arr[i]= s.getAsInt();
    }
    ```
### 1-5. Function의 합성
- Function 타입의 두 람다식을 하나로 합성 - addThen()
    ```java
    Function<String, Integer> f = (s) -> Integer.parseInt(s,16); //s를 16진 정수로 변환
    Function<Integer,String> g = (i) -> Integer.toBinaryString(i); //2진 문자열로 변환
    Function<String, String> h = f.addThen(g); //f+g -> h
    ```
- Function 타입의 두 람다식을 하나로 합성 - compose()
    ```java
    Function<Integer, String> g = (i) -> Integer.toBinaryString(i); //2진 문자열로 변환
    Function<String, Integer> f = (s) -> Integer.parseInt(s,16); // s를 16진 정수로 변환
    Function<Integer, Integer> h = f.compose(g);  //g+f -> h
    ```

### 1-6. Predicate의 결합
- and(), or(), negate()로 두 Predicate를 하나로 결합(default 메서드)
    ```java
    Predicate<Integer> p = i -> i < 100;
    Predicate<Integer> q = i -> i < 200;
    Predicate<Integer> r = i -> i % 2 == 0;

    Predicate<Integer> notP = p.negate(); //i>=100
    Predicate<Integer> all = notP.and(q).or(r); //100<=i && i<200|| i%2==0
    Predicate<Integer> all2 = notP.and(q.or(r));  //100 <=i && (i<200||i%2==0)
    ```
- 등가비교를 위한 Predicate의 작성에는 isEqual()를 사용 (static메서드)
    ```java
    Predicate<String> p = Predicate.isEqual(str1); //isEqual()은 static메서드
    ```
### 1-7. 메서드 참조(method reference)
- 하나의 메서드만 호출하는 람다식은 '메서드 참조'로 간단히 할 수 있다.
  - static메서드 참조 - 람다식: (x)->className.method(x) / 메서드 참조: ClassName::method
  - 인스턴스메서드 참조 - 람다식: (obj.x)->obj.method(x) / 메서드 참죄: ClassName::method
  - 특정 객체 인스턴스메서드 참조 - 람다식: (x) -> obj.method(x) / 메서드 참조: obj::method

- static 메서드 참조
    ```java
    Integer method(String s){
        return Integer.parseInt(s);
    }
                    ↓
    Function<String,Integer> f = (String s) -> Integer.parseInt(s);
                    ↓
    Function<String,Integer> f = Integer::parseInt; // 메서드 참조
    ```
- 인스턴스 메서드 참조
    ```java
    BiFunction<String,String,Boolean> f = (s1,s2) -> s1.equals(s2);
                    ↓
    BiFunction<String,String,Boolean> f = String::equals;
    ```
- 특정 객체의 인스턴스 메서드 참조
    ```java
    MyClass obj = new MyClass();
    Function<String, Boolean> f = (x) -> obj.equals(x); //람다식
    Function<String BOolean> f2 = obj::equals;  //메서드 참조
- new 연산자(생성자,배열)와 메서드 참조
    ```java
    Supplier<MyClass> s = MyClass::new;  //() -> new MyClass()
    Function<Integer, MyClass> f2 = MyClass::new; // (i) -> new MyClass(i)
    Function<Integer int[]> f2 = int[]::new;  //x -> new int[x];
    ```