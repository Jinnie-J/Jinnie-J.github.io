---
title:  "스프링 입문을 위한 자바 객체 지향의 원리와 이해"
excerpt: "스프링 입문을 위한 자바 객체 지향의 원리와 이해 책 리뷰"

categories:
  - Book
tags:
  - [Java, Spring, OOP]

toc: true
toc_sticky: true
 
date: 2022-11-18
last_modified_at: 2022-11-18
---


## 01. 사람을 사랑한 기술
### 자바 - 진정한 객체 지향 언어
객체 지향 언어의 중심에는 클래스(class)가 있다(객체[object]라고 해도 된다). 자바에서는 클래스를 떠나 존재할 수 있는 것은 아무 것도 없다.
심지어 프로그램의 시작점인 main() 메서드마저도 클래스 외부가 아닌 내부에 존재해야 한다. 그리고 모든 메서드도 클래스, 메서드명() 또는 객체.메소드명()으로 접근해야만 한다.

### 스프링 프레임워크는 사상이면서 또 단일 제품이다
스프링 프레임워크에도 끈이름의 끈처럼 스프링을 지배하는 근원적인 요소가 있는데 바로 스프링 삼각형이라고 하는 IoC/DI, AOP, PSA이다.
스프링은 POJO(Plain Old Java Object)에 세 가지 유형의 진동을 줌으로써 거대한 프레임워크를 완성해냈다.   
<br>
스프링 프레임워크의 또 다른 아름다움은 ORM, OXM, JMS, AOP, CoC 등 엔터프라이즈 애플리케이션을 구현하는 데 필요한 거의 모든 서비스를 지원해준다는 것이다.    
<br>
스프링은 PSA(일관성 있는 추상화) 기법을 통해 중구난방으로 구현된 다양한 기술을 표준화된 방식으로 사용할 수 있게 지원해준다. 스프링을 도입하면 엔터프라이즈 애플리케이션을 더 쉽고 편하게, 그리고 더 안정적으로 개발할 수 있다.   

## 02. 자바와 절차적/구조적 프로그래밍
### 자바 프로그램의 개발과 구동
JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.   
자바가 이런 구조를 택한 이유는 기존 언어로 작성한 프로그램은 윈도우 95용, 윈도우 XP용, 윈도우 7용, 윈도우 8용, 리눅스용, 애플 맥 OS X용 등 각 플랫폼 용으로 배포되는 설치파을 따로 준비해야 했던 불편함을 없애기 위해서다.   
자바 개발자는 본인이 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게끔 만들어주는 것이다.
- JDK: Java Development Kit / 자바 개발 도구
- JRE: Java Runtime Environment / 자바 실행 환경
- JVM: Java Virtual Machine / 자바 가상 기계

#### 프로그램이 메모리를 사용하는 방식 
<table>
  <tr>
    <td>코드 실행 영역</td>
    <td>데이터 저장 영역</td>
  </tr>
</table>

#### 객체 지향 프로그램의 메모리 사용 방식
T 메모리 구조
<table>
  <tr>
    <td>코드 실행 영역</td>
    <td colspan="2">스테틱(Static) 영역</td>
  </tr>
  <tr>
  <td></td>
  <td>스택(Stack)영역</td>
  <td>힙(Heap)영역</td>
  </tr>
</table>

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산
객체 지향 프로그래밍은 절차적/구조적 프로그램의 어깨를 딛고 있다. 따라서 객체 지향 언어를 이해하는 데 절차적/구조적 프로그래밍을 아는 것은 큰 도움이 된다.
- 절차적 프로그래밍은 한마디로 표현하자면 goto를 쓰지 말라는 것이다. goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다.
- 구조적 프로그래밍은 함수를 쓰라는 것이다. 함수를 쓰면 좋은 이유는 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있기 떄문이다.
여기에 더해 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수 보다는 지역 변수를 쓰라는 것도 있다.

### main() 메서드: 메서드 스택 프레임
JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다. 가상의 기계인 JVM에 전원을 넣어 부팅하는 것이다.   
<br>
JVM은 가장 먼저 java.lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다. java.lang 패키지가 있기에 System.out.println() 같은 메서드를 쓸 수 있게 되는 것이다.  
다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.
#### main() 메서드가 싫행되기 전 JVM에서 수행하는 전처리 작업들
- java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다.
- import된 패키지를 T apahfldml 스태틱 영역에 배치한다.
- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.

### 지역 변수와 메모리
- 지역 변수는 스택 영역에서 일생을 보낸다. 그것도 스택 프레임 안에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다.   
- 클래스 멤버 변수는 스태틱 영역에서 일생을 보낸다. 스태틱 영역에 한번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.   
- 객체 멤버 변수는 힙에서 일생을 보낸다. 객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다.   

외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.

### 전역 변수와 메모리
두 메서드 사이에 값을 전달하는 방법은 메서드를 호출할 때 메서드의 인자를 이용하는 방법과 메서드를 종료할 때 반환값을 넘겨주는 방법이 있다. 또한 전역 변수를 사용할 수도 있다.   
전역 변수는 코드 어느 곳에서나 사용한다고 해서 공유 변수라고도 한다.

#### 왜 전역 변수를 쓰지 말라고 할까?
프로젝트 규모에 따라 코드가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 때문이다.   
<br>
결론적으로 전역 변수는 피할 수 있다면 피해야 하는 존재이다. 다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 괜찮다. 가장 대표적인 전역 상수 후보로는 원주율을 나타내는 PI 값 등이 있다.

### 멀티 스레드 / 멀티 프로세스의 이해
![thread](https://user-images.githubusercontent.com/62706198/202731215-d72f9c15-2d81-4e6f-aba2-3ed243fa9c31.jpeg)
- 멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.   
- 멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.

멀티 프로세스는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 그에 반해 멀티 스레드는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.   
<br>
멀티 스레드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.   

#### 멀티 스레드에서 전역 변수 사용의 문제점
쓰기 가능한 전역 변수를 사용하게 되면 스레드 안정성이 깨진다고 표현한다. 물론 이를 보완하는 방법으로 락(lock)을 거는 방법이 있기는 하다. 하지만 락을 거는 순간 멀티 스레드의 장점은 버린 것과 같다.

